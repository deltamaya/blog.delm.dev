---
title: 進階OpenGL
date: 2025-03-11
tags: ['graphics', 'opengl']
authors: ['Maya']
ai: True
draft: False
---
# 深度測試
現在我們知道OpenGL中的每一個片段都有一個自己的坐標，其中的z坐標表示距離螢幕的距離，比如當我們需要近處的物體遮擋遠處的物體時，就需要進行**深度測試**。深度測試是指根據片段的深度(z坐標)來判斷該片段是否應該被展示。深度測試在沒有優化的情況下是在**片段著色器之後**（以及後面的模板測試之後），在**螢幕空間**運行的。

> [!NOTE]
> 現在大部分的GPU都提供一個叫做**提前深度測試**（Early Depth Testing）的硬體特性。提前深度測試允許深度測試在片段著色器之前運行。只要我們清楚一個片段永遠不會是可見的（它在其他物體之後），我們就能提前丟棄這個片段。
> 片段著色器通常開銷都是很大的，所以我們應該儘可能避免運行它們。當使用提前深度測試時，片段著色器的一個限制是你不能寫入片段的深度值。如果一個片段著色器對它的深度值進行了寫入，提前深度測試是不可能的。OpenGL不能提前知道深度值。

深度測試默認是關閉的，可以通過`GL_DEPTH_TEST`選項來啟用它。
```cpp
glEnable(GL_DEPTH_TEST);
```

如果一個片段通過了深度測試，接下來會將這個片段的z值更新深度緩衝區，用來進行後面的判斷。如果沒有通過測試，就會直接丟棄該片段。如果開啟了深度緩衝，你還需要在每一次渲染循環中**清空**深度緩衝，否則上一幀的深度緩衝就會對當前幀的深度探測產生負面影響：
```cpp
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```
如果你希望再有的時候只進行探測而不進行更新深度緩衝區的操作，可以通過設置深度掩碼`DepthMask`為`false`即可
```cpp
glDepthMask(false);
```
## 深度測試函數
我們可以通過不同的深度測試函數來進行深度探測，默認的比較方法是`GL_LESS`，它會**丟棄**當深度值大於等於當前深度緩衝值的所有片段。
```cpp
glEnable(GL_DEPTH_TEST);
glDepthFunc(GL_LESS);
```
OpenGL還提供了`GL_ALWAYS`、`GL_NEVER`、`GL_EQUAL`、`GL_GEQUAL`等內置的探測函數，
假如我們啟用了`GL_ALWAYS`深度測試將永遠通過，我們能看到的永遠是我們最後進行渲染的片段。

## 精度
深度緩衝中包含了一個[0.0, 1.0]的深度值，它可以代表平截頭體從近平面到遠平面的所有z坐標。這個變換通常是一個這樣的變換函數：

$$
F_{depth}=\frac{1/z-1/near}{1/far-1/near}
$$
使用這樣的非線性變換函數而不是一個線性變換可以使我們在**近處**的探測精度**更高**，而遠處的精度更低，增強了近處的視覺體驗。

## 深度衝突
一個常見的視覺錯誤就是當兩個片段的深度值非常接近以至於深度測試無法明確判斷誰在前誰在後的時候就會產生**深度衝突**。看起來就是兩個片段在競爭誰處於頂端，具體表現就是一個區域可以看到兩個片段高頻交替顯示或者是兩個片段的條紋。深度衝突在遠處格外明顯，因為非線性變換導致遠處的精度較低。

我們可以通過如下方法來規避深度衝突：

- 不要將兩個物體擺放得太近，很有效。
- 儘可能將近平面設置得更遠，如果近平面更遠就意味著我們可以在更遠的距離擁有更高的精度，但設置過大可能導致物體直接被裁剪掉。
- 使用更高精度的緩衝，大部分緩衝都是24bit的，但大部分顯卡都支持32bit的緩衝，這可以極大地提升精度。
# 模板測試
與深度緩衝相似，**模板測試**（Stencil Test）也有一個緩衝區，叫做模板緩衝區，這個緩衝區的每一個單位是一個8位整數來保存模板值。

模板緩衝操作允許我們在渲染片段時將模板緩衝設定為一個特定的值。通過在渲染時修改模板緩衝的內容，我們**寫入**了模板緩衝。在同一個（或者接下來的）幀中，我們可以**讀取**這些值，來決定丟棄還是保留某個片段。使用模板緩衝的時候你可以盡情發揮，但大體的步驟如下：

- 啟用模板緩衝的寫入。
- 渲染物體，更新模板緩衝的內容。
- 禁用模板緩衝的寫入。
- 渲染（其它）物體，這次根據模板緩衝的內容丟棄特定的片段。

模板測試同樣也是使用`glEnable`來啟用
```cpp
glEnable(GL_STENCIL_TEST);
```
跟深度測試一樣，每次迭代也需要清空緩衝區
```cpp
glClear(GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
```

與深度測試不同，模板測試的掩碼更複雜，設定的掩碼值會與要寫入緩衝區的值進行邏輯與操作。這裡設定`0xFF`表示不對寫入值進行修改，如果是`0x00`表示不進行寫入，效果與`glDepthMask(false)`相同，會禁用掩碼。
```cpp
glStencilMask(0xFF);
```
同樣的，我們也可以使用`glStencilFunc`和`glStencilOp`來分別設定模板測試的比較函數和在不同情況下如何更新緩衝。

## 物體輪廓
一個常見的關於模板測試的例子就是顯示物體輪廓，對物體進行描邊，以下是如何通過模板測試實現這個功能：
1. 啟用模板寫入。
2. 在繪製（需要添加輪廓的）物體之前，將模板函數設置為GL_ALWAYS，每當物體的片段被渲染時，將模板緩衝更新為1。
3. 渲染物體。
4. 禁用模板寫入以及深度測試。
5. 將每個物體縮放一點點。
6. 使用一個不同的片段著色器，輸出一個單獨的（邊框）顏色。
7. 再次繪製物體，但只在它們片段的模板值不等於1時才繪製。
8. 再次啟用模板寫入和深度測試。

# 混合

如果我們的紋理中有**alpha通道**，就可以通過這個通道來實現半透明的效果，這個過程叫做**alpha混合**。OpenGL的混合是通過這個分量實現的：

$$
 C_{result}=C_{source}*F_{source}+C_{destination}*F_{destination}
$$
其中源顏色向量和目標顏色向量是OpenGL自動為我們設定的，其中源顏色分量通常為正在處理的片段的顏色，目標顏色分量為顏色緩衝區中現有的顏色。但源因子和目標因子的值可以由我們來決定。

OpenGL允許我們使用`glEnable`來啟用混合。
```cpp
glEnable(GL_BLEND);
```
同時我們可以通過`glBlendFunc`設置用來混合的函數，`glBlendFunc(sfactor, dfactor)`可以接受兩個參數，可以用來設置源和目標因子。OpenGL為我們定義了很多選項，以下是一些常用的選項：

| 選項                       | 效果       |
| ------------------------ | -------- |
| `GL_ZERO`                | 因子為0     |
| `GL_ONE`                 | 因子為1     |
| `GL_SRC_COLOR`           | 源顏色向量    |
| `GL_DST_COLOR`           | 目標顏色向量   |
| `GL_SRC_ALPHA`           | 源alpha   |
| `GL_DST_ALPHA`           | 目標alpha  |
| `GL_ONE_MINUS_SRC_ALPHA` | 1-源alpha |
| `GL_CONSTANT_ALPHA`      | 常數alpha  |

如果我們需要上面的不透明物體能夠看到下面的物體，常見的做法是使用：
```cpp
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
```
上面的代碼將會在處理一個半透明或者透明的物體時將這個物體在alpha混合的地方將自己的顏色與後面已經通過深度測試的物體的顏色進行混合。如果說後面的物體同樣是一個有非不透明的物體，那麼這個處理是正常的，但是如果先渲染的前面的物體，後面的物體就無法通過深度測試，導致後面的物體顏色沒有進行混合。

所以說通常的渲染順序是：
1. 渲染所有不透明物體
2. 對所有透明物體按照距離視口的距離進行排序
3. 按照順序渲染透明物體

在場景中排序物體是一個很困難的技術，很大程度上由你場景的類型所決定，更別說它額外需要消耗的處理能力了。完整渲染一個包含不透明和透明物體的場景並不是那麼容易。更高級的技術還有**次序無關透明度**（Order Independent Transparency, OIT），如果有時間我會再去研究。

# 面剔除

當我們繪製一個**閉合**的形狀時，每一個面都有兩側，而於此同时我們只能觀察到一個面，那我們看不到的那個面依然會占用計算資源，導致速度變慢。OpenGL提供的**面剔除**（Face Culling）可以解決這個問題。

如果說我們繪製的閉合形狀是由多個三角形組成的，當我們在定義這些三角形的頂點的時候，一共會有兩種點的環繞方式，順時針和逆時針。

OpenGL默認從這個立方體的外面觀察為**逆時針**的時候這是**正面**，而順時針是反面，並且在開啟面剔除後OpenGL默認剔除反面。通過如下代碼可以開啟面剔除功能。
```cpp
glEnable(GL_CULL_FACE);
```
同時我們還可以使用
```cpp
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```0
來告訴OpenGL我們要剔除正面。

當然我們也可以設置到底順時針還是逆時針是正面：
```cpp
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```1
上面的代碼定義順時針（Clock-wise）是正面。
面剔除是一個很棒的工具，但你需要記住哪些物體能夠從面剔除中獲益，而哪些物體不應該被剔除。

## 與深度測試的關係?
我在學習到這裡的時候發現這個功能好像與之前的深度測試有些類似，於是仔細對比了一下。

**深度測試**發生在**片段處理**之後，也就是當片段著色器運行結束之後，操作發生在像素級別，僅僅影響到渲染。

**面剔除**發生在**圖元組裝**和**光柵化**之間，它通過判斷三角形的朝向來選擇性剔除一些圖元（三角形），它的輸出是光柵化也就是片段著色器的輸入。面剔除可以提前丟棄我們想要剔除的面，減少了片段著色器的計算量，也就減小了開銷。