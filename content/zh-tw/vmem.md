---
title: 深入了解虛擬記憶體
date: 2025-04-29
tags: ['operating-system']
authors: ['Maya']
ai: True
draft: False
---
最近在學習的過程中發現自己對操作系統和記憶體理解的知識儲備有些不太夠用了，於是再來學習一下關於操作系統的一些知識，就從虛擬記憶體開始吧：

## 什麼是虛擬記憶體？
操作系統的一大功能就是對硬體進行**抽象**，來向軟體提供一個介面來操作硬體，而虛擬記憶體就是操作系統對記憶體的抽象，虛擬記憶體是由**操作系統**管理的。

如果是應用直接操作物理記憶體，就像單晶片，那麼一個硬體上幾乎就不能運行多個程式，A程式的程式員並不知道B程式要使用哪些記憶體，因此A程式和B程式就會相互影響彼此的記憶體，這是不可接受的。因此操作系統抽象出了虛擬記憶體，對應用程式來說就像自己獨佔所有記憶體一樣。

虛擬記憶體的是抽象出來的，所以它的大小並不受限於物理記憶體的大小。比如說，32位的系統上可以有$2^{32}$也就是4G的虛擬記憶體，但是記憶體卻可以是1G甚至只有幾百K。

## 虛擬記憶體的作用

就像剛才說的，虛擬記憶體可以改變行程對記憶體的感知，允許多個行程操作同時操作記憶體而不會彼此影響。操作系統還可以對行程實際使用的記憶體進行重新排布，壓縮甚至是換出到磁碟，這些操作應用程式**都不會感知到**。 

## 虛擬記憶體的是如何實現的

操作系統通過分頁來對記憶體這個巨大的位元組陣列進行劃分，一個頁的大小一般是4K，每一個記憶體位元組的位址都可以由一個頁號+一個頁面內的偏移量來計算得到。同樣的，物理記憶體也可以劃分為一個個頁面，它們之間的大小是相同的。

那麼，每個虛擬記憶體頁就可以有3種狀態：
1. 已經被映射，並且存放在物理記憶體
2. 已經被映射，沒有存放在物理記憶體
3. 沒有被映射

這裡的「映射」指的是將虛擬記憶體映射到行程的位址空間，一個應用程式想要操作虛擬記憶體必須將它映射到自己的**位址空間**，否則就會觸發**段錯誤**。所謂段錯誤就是應用程式存取到了不屬於自己的虛擬記憶體段或者沒有以指定的特權等級存取了某個虛擬記憶體段。

對應用程式來說，對記憶體的使用流程大致如下： 

1. 向操作系統請求對指定大小的或者位置的虛擬記憶體進行映射，如果成功，那麼這些虛擬記憶體的狀態就是上面的狀態2
2. 使用記憶體，操作系統如果發現行程使用到了狀態2的記憶體，但是發現這個虛擬記憶體頁沒有緩存在物理記憶體中，就會觸發缺頁中斷，由操作系統對應的中斷處理程式來將這個虛擬記憶體頁放到物理記憶體，轉化為狀態1，這個過程中可能還會涉及到虛擬記憶體頁的換出。
3. 釋放記憶體，行程向操作系統請求解除虛擬記憶體映射，將行程的這些虛擬記憶體設置為狀態3，那麼物理記憶體中的實際資料也可以被釋放了

但是現在依舊沒有解釋為什麼虛擬記憶體可以讓多個行程同時運行，如果A和B同時操作記憶體0x114514為什麼不會發生錯誤呢？

這是因為操作系統為每一個行程維護一個頁表，我們先假設AB行程都正確請求了記憶體，並且0x114514記憶體對應的虛擬記憶體頁都是狀態1，其中的一個表項記錄了行程的每一個虛擬記憶體頁映射到物理頁框的哪個位置，比如A的0x114514對應的頁可能在物理記憶體0x1919處，B的0x114514可能對應0x810的物理記憶體位置。
當然，上面僅僅是舉例說明不同行程的同一個虛擬位址會映射到不同的物理位址，實際的具體數值可能沒有很精確的對應現實情況。


## 虛擬記憶體的優化

簡單介紹：
### 多級頁表
如果一個32位系統，位址空間有$2^{32}$也就是4G，如果我們採用4K的頁就需要每個行程維護$2^{32}/2^{12}=1M$個頁的頁表，如果一個頁表項佔用4B，就需要4M每個行程，如果是64位的位址空間就更加恐怖了。

因此，我們引入了多級頁表，通過層級結構的頁表來減少需要記錄的頁表項數量。

## TLB
如果每次訪存的操作都需要去查頁表未免太慢了，因此我們又引入了**快表**(TLB)，直接緩存最常用的虛擬頁映射，命中緩存的情況下大幅度減少訪存的時間開銷。