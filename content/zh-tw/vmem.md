---
title: 進一步理解虛擬內存
date: 2025-04-29
tags: ['operating-system']
authors: ['Maya']
ai: True
draft: false
---
最近在學習的過程中發現自己對操作系統和內存理解的知識儲備有些不太夠用了，於是再來學習一下關於操作系統的一些知識，就從虛擬內存開始吧：

## 什麼是虛擬內存？
操作系統的一大功能就是對硬件進行**抽象**，來向軟件提供一個接口來操作硬件，而虛擬內存就是操作系統對內存的抽象，虛擬內存是由**操作系統**管理的。

如果是應用直接操作物理內存，就像單片機，那麼一個硬件上幾乎就不能運行多個程序，A程序的程序員並不知道B程序要使用哪些內存，因此A程序和B程序就會相互影響彼此的內存，這是不可接受的。因此操作系統抽象出了虛擬內存，對應用程序來說就像自己獨佔所有內存一樣。

虛擬內存是抽象出來的，所以它的大小並不受限於物理內存的大小。比如說，32位的系統上可以有$2^{32}$也就是4G的虛擬內存，但是內存卻可以是1G甚至只有幾百K。

## 虛擬內存的作用

就像剛才說的，虛擬內存可以改變進程對內存的感知，允許多個進程同時操作內存而不會彼此影響。操作系統還可以對進程實際使用的內存進行重新排布、壓縮甚至是換出到磁碟，這些操作應用程序**都不會感知到**。

## 虛擬內存是如何實現的

操作系統通過分頁來對內存這個巨大的字節數組進行劃分，一個頁的大小一般是4K，每一個內存字節的地址都可以由一個頁號+一個頁面內的偏移量來計算得到。同樣的，物理內存也可以劃分為一個個頁面，它們之間的大小是相同的。

那麼，每個虛擬內存頁就可以有3種狀態：
1. 已經被映射，並且存放在物理內存
2. 已經被映射，沒有存放在物理內存
3. 沒有被映射

這裡的“映射”指的是將虛擬內存映射到進程的地址空間，一個應用程序想要操作虛擬內存必須將它映射到自己的**地址空間**，否則就會觸發**段錯誤**。所謂段錯誤就是應用程序訪問到了不屬於自己的虛擬內存段或者沒有以指定的特權級別訪問了某個虛擬內存段。

對應用程序來說，對內存的使用流程大致如下：

1. 向操作系統請求對指定大小的或者位置的虛擬內存進行映射，如果成功，那麼這些虛擬內存的狀態就是上面的狀態2
2. 使用內存，操作系統如果發現進程使用到了狀態2的內存，但是發現這個虛擬內存頁沒有緩存在物理內存中，就會觸發缺頁中斷，由操作系統對應的終端處理程序來將這個虛擬內存頁放到物理內存，轉化為狀態1，這個過程中可能還會涉及到虛擬內存頁的換出。
3. 釋放內存，進程向操作系統請求解除虛擬內存映射，將進程的這些虛擬內存設置為狀態3，那麼物理內存中的實際數據也可以被釋放了。

但是現在依舊沒有解釋為什麼虛擬內存可以讓多個進程同時運行，如果A和B同時操作內存0x114514為什麼不會發生錯誤呢？

這是因為操作系統為每一個進程維護一個頁表，我們先假設AB進程都正確請求了內存，並且0x114514內存對應的虛擬內存頁都是狀態1，其中的一個表項記錄了進程的每一個虛擬內存頁映射到物理頁框的哪個位置，比如A的0x114514對應的頁可能在物理內存0x1919處，B的0x114514可能對應0x810的物理內存位置。
當然，上面僅僅是舉例說明不同進程的同一個虛擬地址會映射到不同的物理地址，實際的具體數值可能沒有很精確的對應現實情況。

## 虛擬內存的優化

簡單介紹：
### 多級頁表
如果一個32位系統，地址空間有$2^{32}$也就是4G，如果我們採用4K的頁就需要每個進程維護$2^{32}/2^{12}=1M$個頁的頁表，如果一個頁表項佔用4B，就需要4M每個進程，如果是64位的地址空間就更加恐怖了。

因此，我們引入了多級頁表，通過層級結構的頁表來減少需要記錄的頁表項數量。

## TLB
如果每次訪存的操作都需要去查頁表未免太慢了，因此我們又引入了**快表**(TLB)，直接緩存最常用的虛擬頁映射，命中緩存的情況下大幅度減少訪存的時間開銷。