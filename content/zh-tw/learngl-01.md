---
title:     初見OpenGL
authors: ['Maya']
ai: True
draft: False
date: 2025-02-02
tags: ['opengl', 'graphics']
---
> [!NOTE]
> 此篇博客更倾向於自己的學習心得，而不是進行OpenGL的教學，如果你想學習OpenGL請移步[LearnOpenGL](https://learnopengl.com/).

# 什麼是OpenGL?
在[ArcVP開發日誌](https://blog.delm.dev/blog/arcvp-01)中以及介紹過了這一點，簡而言之OpenGL是一個圖形API的標準，各家顯卡廠商會自己實現一套OpenGL，就像是C++標準和不同的編譯器之間的關係。

## 核心模式與立即渲染模式

早期的OpenGL使用**立即渲染模式**（Immediate mode，也就是固定渲染管線），這個模式下繪製圖形很方便。OpenGL的大多數功能都被庫隱藏起來，開發者很少有控制OpenGL如何進行計算的自由。而開發者迫切希望能有更多的靈活性。隨著時間推移，規範越來越靈活，開發者對繪圖細節有了更多的掌控。立即渲染模式確實容易使用和理解，但是效率太低。因此從OpenGL3.2開始，規範文檔開始廢棄立即渲染模式，並鼓勵開發者在OpenGL的核心模式(Core-profile)下進行開發，這個分支的規範完全移除了舊的特性。

當使用OpenGL的**核心模式**時，OpenGL迫使我們使用現代的函數。當我們試圖使用一個已廢棄的函數時，OpenGL會拋出一個錯誤並終止繪圖。現代函數的優勢是更高的靈活性和效率，然而也更難於學習。立即渲染模式從OpenGL**實際**運作中抽象掉了很多細節，因此它在易於學習的同時，也很難讓人去把握OpenGL具體是如何運作的。現代函數要求使用者真正理解OpenGL和圖形編程，它有一些難度，然而提供了更多的靈活性，更高的效率，更重要的是可以更深入的理解圖形編程。

這也是為什麼我們的教程面向OpenGL3.3的核心模式。雖然上手更困難，但這份努力是值得的。

現今，更高版本的OpenGL已經發布（寫作時最新版本為4.5），你可能會問：既然OpenGL 4.5都出來了，為什麼我們還要學習OpenGL 3.3？答案很簡單，所有OpenGL的更高的版本都是在3.3的基礎上，引入了額外的功能，並沒有改動核心架構。新版本只是引入了一些更有效率或更有用的方式去完成同樣的功能。因此，所有的概念和技術在現代OpenGL版本裡都保持一致。當你的經驗足夠，你可以輕鬆使用來自更高版本OpenGL的新特性。

## GLAD
因為**OpenGL**只是個標準/規範，具體的實現是由驅動開發商針對特定顯卡實現的。由於**OpenGL**驅動版本眾多，它大多數函數的位置都無法在編譯時確定下來，需要在運行時查詢。所以任務就落在了開發者身上，開發者需要在運行時獲取函數地址並將其保存在一個函數指針中供以後使用。而**GLAD**就是用於簡化這一過程的一個庫。

# 著色器
**著色器**就是能夠在GPU上運行的程序，著色器分為很多種，每一個著色器只關心渲染或者計算中的一小部分工作，GPU上可以同時運行大量著色器實例，並且有一部分著色器是可以編程的。一般來說，一種著色器的輸入通常是另一種著色器的輸出。下面藍色的是可編程的著色器。

![著色器](https://learnopengl.com/img/getting-started/pipeline.png)
## 頂點著色器
頂點著色器，即**Vertex Shader**，是幾個可編程著色器中的一個。如果我們打算做渲染的話，現代OpenGL需要我們至少設置一個頂點和一個片段著色器。它用於處理每個頂點的數據（如位置、法線、紋理坐標等）。將頂點從模型坐標轉換到屏幕坐標，並進行其他頂點相關的變換。一般來說，頂點著色器就是將空間中的點進行變換到2D平面。

> [!TIP]
> 平面上的點**不是**屏幕上的像素！

## 幾何著色器
頂點著色器階段的輸出可以選擇性地傳遞給**幾何著色器**(Geometry Shader)。幾何著色器將一組頂點作為輸入，這些頂點形成圖元，並且能夠通過發出新的頂點來形成新的（或其他）圖元來生成其他形狀。

## 圖元裝配

**圖元裝配**(Primitive Assembly)階段將頂點著色器（或幾何著色器）輸出的所有頂點作為輸入（如果是`GL_POINTS`，那麼就是一個頂點），並將所有的點裝配成指定圖元的形狀。圖元裝配階段的輸出會被傳入**光柵化階段**(Rasterization Stage)，這裡它會把圖元映射為最終屏幕上相應的像素，生成供**片段著色器**(Fragment Shader)使用的**片段**(Fragment)。在片段著色器運行之前會執行**裁切**(Clipping)。裁切會丟棄超出你的視圖以外的所有像素，用來提升執行效率。

## 片段著色器
**Fragment Shader**，通常用於結合紋理、光照計算、陰影效果和其他信息，生成每個像素最終的顏色。

在所有對應顏色值確定以後，最終的對象將會被傳到最後一個階段，我們叫做**Alpha測試和混合**(Blending)階段。這個階段檢測片段的對應的深度（和模板(Stencil)）值，用它們來判斷這個像素是其它物體的前面還是後面，決定是否應該丟棄。這個階段也會檢查**alpha值**（alpha值定義了一個物體的透明度）並對物體進行**混合**(Blend)。所以，即使在片段著色器中計算出來了一個像素輸出的顏色，在渲染多個三角形的時候最後的像素顏色也可能完全不同。

## 著色器程序
一個著色器Program可以包含上面的一系列Shader，我們可以將多個Shader Attach到一個Program上，然後執行Link操作來生成一個Shader Program管線。

# 頂點輸入

在進行繪製之前，需要給OpenGL提供一些頂點的坐標。這些坐標需要位於**[-1~1]**之間，這個坐標範圍叫做**標準化設備坐標**。只有這個範圍內的頂點最終才會顯示在屏幕上。這個坐標可以理解為窗口中心為原點的一個笛卡爾坐標。

一旦你的頂點坐標已經在頂點著色器中處理過，它們就應該是**標準化設備坐標**了，標準化設備坐標是一個x、y和z值在-1.0到1.0的一小段空間。任何落在範圍外的坐標都會被丟棄/裁剪，不會顯示在你的屏幕上。

使用`glViewport`函數提供的數據進行**視口轉換**，可以將**標準化設備坐標**轉化為**屏幕空間坐標**。然後被轉化為片段送往片段著色器。

# Vertex Array
![Vertex](https://learnopengl-cn.github.io/img/01/04/vertex_array_objects_ebo.png)
上圖是Vertex Array、Vertex Buffer、Element Buffer之間的關係，一個Vertex Array是我們使用的所有頂點屬性的抽象，其中可以包含多個Attribute Pointer，指向Vertex Buffer中的具體數據，這些數據用來描述一個頂點的屬性。

使用一個緩衝區而不是單獨的頂點可以保證，他們通常被一次發送到GPU的內存中，將數據從CPU發送到GPU是一個緩慢的過程，因此我們需要一次發送盡可能多的數據。

而Element Buffer是一個緩衝區，就像Vertex Buffer一樣，它存儲 OpenGL 用來決定要繪製哪些頂點的索引。這種所謂的索引繪製(Indexed Drawing)正是我們問題的解決方案。

# 紋理
紋理通俗來講就是一個遊戲裡的貼圖，我們會把折疊無縫貼合到模型上，使得表現出可以複雜的外觀。

我們可以使用片段著色器來使用紋理，首先創建並綁定紋理，然後為其指定格式並設置數據即可。

在進行紋理數據讀取的時候有一個常見的坑，就是圖片數據一般以左上角為坐標原點，而OpenGL紋理是以左下角為坐標原點，如果直接使用的話會導致圖片上下顛倒，所以我們需要在讀取圖像數據的時候進行上下翻轉。

## 紋理過濾

如果說我們將一個紋理應用到一個大小不同的表面上的時候，就會產生縮放，我們可以通過設置不同的紋理過濾方式來進行不同的縮放。比如說使用`GL_LINEAR`可以使用線性插值，`GL_NEAREST`可以進行截斷。

## mipmap
如果每次都使用完整的貼圖來應用在一個很小的表面上就會導致開銷過大。OpenGL為我們提供了解決方案，就是`mipmap`。

它可以理解為預先創建好的不同規格的貼圖，比如你提供一個500x500的貼圖，使用mipmap，OpenGL就可以預先創建好200x200、50x50大小的貼圖，當我們將貼圖應用於很小的物體上的時候就直接使用50x50大小的變體，減少計算開銷。同樣的，可以使用`GL_NEAREST_MIPMAP_LIENAR`來指定使用哪個mipmap變體。

# 變換

這裡需要介紹一些基本的線代：

## 矩陣乘法

## 矩陣與矩陣
假設我們稱一個x行y列的矩陣為$M_{x,y}$，則矩陣$M_{m,n}$與$M_{p,q}$之間的相乘需要$n=p$，產生的結果為$M_{n,q}$

且矩陣乘法不滿足交換律，即$A\cdot B \neq B \cdot A$

如下是一個簡單的矩陣相乘的實現
```cpp
template <typename T> using mat = std::vector<std::vector<T>>;
mat<int> matrix_multiply(mat<int> const &lhs, mat<int> const &rhs) {
    // Check if matrices are empty
    if (lhs.empty() || rhs.empty() || lhs.front().empty() ||
        rhs.front().empty()) {
        throw std::runtime_error("empty matrix");
    }
    // Dimensions
    int m = lhs.size();         // rows of lhs
    int n = lhs.front().size(); // columns of lhs
    int p = rhs.size();         // rows of rhs
    int q = rhs.front().size(); // columns of rhs
    // Check compatibility: n must equal p
    if (n != p) {
        throw std::runtime_error("matrix dimensions incompatible");
    }
    // Check consistency of inner vector sizes
    for (const auto &row : lhs) {
        if (row.size() != n)
            throw std::runtime_error("inconsistent lhs column sizes");
    }
    for (const auto &row : rhs) {
        if (row.size() != q)
            throw std::runtime_error("inconsistent rhs column sizes");
    }
    // Result matrix: m × q
    mat<int> ret(m, std::vector<int>(q, 0));
    // Matrix multiplication
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < q; j++) {
            for (int k = 0; k < n; k++) { // Use n (or p, since n == p)
                ret[i][j] += lhs[i][k] * rhs[k][j];
            }
        }
    }
    return ret;
}
```

## 矩陣與向量

同理，我們可以假設一個n維向量為一個$M_{n,1}$來進行矩陣和向量之間的乘法。

但是為什麼我們會關心矩陣能否乘以一個向量？好吧，正巧，很多有趣的2D/3D變換都可以放在一個矩陣中，用這個矩陣乘以我們的向量將**變換**(Transform)這個向量。如果你仍然有些困惑，我們來看一些例子，你很快就能明白了。

## 單位矩陣

**單位矩陣**是一個除了對角線全是0的矩陣，使用單位矩陣作為變換矩陣可以使一個向量完全不變：

$$
\begin{bmatrix}
1 & 0& 0&0\\
0 & 1& 0&0\\
0 & 0& 1&0\\
0 & 0& 0&1\\
\end{bmatrix}
\cdot
\begin{bmatrix}
1\\
2\\
3\\
4
\end{bmatrix}
=
\begin{bmatrix}
1\\
2\\
3\\
4
\end{bmatrix}
$$

> [!NOTE]
> 你可能會奇怪一個沒變換的變換矩陣有什麼用？單位矩陣通常是生成其他變換矩陣的起點，如果我們深挖線性代數，這還是一個對證明定理、解線性方程非常有用的矩陣。

## 縮放

OpenGL通常是在3D空間進行操作的，對於2D的情況我們可以把z軸縮放1倍，這樣z軸的值就不變了。我們剛剛的縮放操作是不均勻(Non-uniform)縮放，因為每個軸的縮放因子(Scaling Factor)都不一樣。如果每個軸的縮放因子都一樣那麼就叫均勻縮放(Uniform Scale)。如下的變換矩陣可以將一個向量分別進行不同程度的縮放：

$$
\begin{bmatrix}
S_1 & 0& 0&0\\
0 & S_2& 0&0\\
0 & 0& S_3&0\\
0 & 0& 0&1\\
\end{bmatrix}
\cdot
\begin{bmatrix}
x\\
y\\
z\\
1
\end{bmatrix}
=
\begin{bmatrix}
S_1\cdot x\\
S_2\cdot y\\
S_3\cdot z\\
1
\end{bmatrix}
$$
注意，第四個縮放向量仍然是1，因為在3D空間中縮放w分量是無意義的。w分量另有其他用途，在後面我們會看到。
## 位移
**位移**(Translation)是在原始向量的基礎上加上另一個向量從而獲得一個在不同位置的新向量的過程，從而在位移向量基礎上**移動**了原始向量。我們已經討論了向量加法，所以這應該不會太陌生。

$$
\begin{bmatrix}
1 & 0& 0&T_x\\
0 & 1& 0&T_y\\
0 & 0& 1&T_z\\
0 & 0& 0&1\\
\end{bmatrix}
\cdot
\begin{bmatrix}
x\\
y\\
z\\
1
\end{bmatrix}
=
\begin{bmatrix}
x+T_x\\
y+T_y\\
z+T_z\\
1
\end{bmatrix}
$$

有了位移矩陣我們就可以在3個方向(x, y, z)上移動物體，它是我們的變換工具箱中非常有用的一個變換矩陣。
## 旋轉

在3D空間中旋轉需要定義一個角**和**一個旋轉軸(Rotation Axis)。物體會沿著給定的旋轉軸旋轉特定角度。如果你想要更形象化的感受，可以試試向下看著一個特定的旋轉軸，同時將你的頭部旋轉一定角度。當2D向量在3D空間中旋轉時，我們把旋轉軸設為z軸（嘗試想像這種情況）旋轉矩陣在3D空間中每個單位軸都有不同定義，旋轉角度用$\theta$表示：

利用旋轉矩陣我們可以把任意位置向量沿一個單位旋轉軸進行旋轉。也可以將多個矩陣複合，比如先沿著x軸旋轉再沿著y軸旋轉。但是這會很快導致一個問題——**萬向節死鎖**。在這裡我們不會討論它的細節，但是對於3D空間中的旋轉，一個更好的模型是沿著任意的一個軸，比如單位向量$(0.662, 0.2, 0.7222)$旋轉，而不是對一系列旋轉矩陣進行複合。

避免萬向節死鎖的真正解決方案是使用**四元數**(Quaternion)，它不僅更安全，而且計算會更有效率。
## 矩陣的結合

通過上面介紹的不同的變換矩陣，我們就可以對一個向量在空間中進行任意變換。根據矩陣之間的乘法，我們可以將多個變換矩陣結合到一個矩陣中。

> [!TIP]
> 當矩陣相乘時我們通常先寫位移再寫縮放變換。
> 矩陣乘法是不遵守交換律的，這意味著它們的順序很重要。當矩陣相乘時，在最右邊的矩陣是第一個與向量相乘的，所以你應該從右向左讀這個乘法。
> 建議您在組合矩陣時，先進行縮放操作，然後是旋轉，最後才是位移，否則它們會（消極地）互相影響。
> 比如，如果你先位移再縮放，位移的向量也會同樣被縮放！

# 坐標空間

將坐標變換為標準化設備坐標，接著再轉化為屏幕坐標的過程通常是分步進行的，也就是類似於流水線那樣子。在流水線中，物體的頂點在最終轉化為屏幕坐標之前還會被變換到多個坐標系統(Coordinate System)。將物體的坐標變換到幾個**過渡**坐標系(Intermediate Coordinate System)的優點在於，在這些特定的坐標系中，一些操作或運算更加方便和容易，這一點很快就會變得很明顯。對我們來說比較重要的總共有5個不同的坐標系統：

- **局部空間**(Local Space，或者稱為物體空間(Object Space))
- **世界空間**(World Space)
- **觀察空間**(View Space，或者稱為視覺空間(Eye Space))
- **裁剪空間**(Clip Space)
- **屏幕空間**(Screen Space)

為了將坐標從一個坐標系變換到另一個坐標系，我們需要用到幾個變換矩陣，最重要的幾個分別是模型(Model)、觀察(View)、投影(Projection)三個矩陣。我們的頂點坐標起始於局部空間(Local Space)，在這裡它稱為局部坐標(Local Coordinate)，它在之後會變為世界坐標(World Coordinate)、觀察坐標(View Coordinate)、裁剪坐標(Clip Coordinate)，並最後以屏幕坐標(Screen Coordinate)的形式結束。下面的這張圖展示了整個流程以及各個變換過程做了什麼：

![coordinate transform](https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png)
1. 局部坐標是對象相對於局部原點的坐標，也是物體起始的坐標。
2. 下一步是將局部坐標變換為世界空間坐標，世界空間坐標是處於一個更大的空間範圍的。這些坐標相對於世界的全局原點，它們會和其它物體一起相對於世界的原點進行擺放。
3. 接下來我們將世界坐標變換為觀察空間坐標，使得每個坐標都是從攝像機或者說觀察者的角度進行觀察的。
4. 坐標到達觀察空間之後，我們需要將其投影到裁剪坐標。裁剪坐標會被處理至-1.0到1.0的範圍內，並判斷哪些頂點將會出現在屏幕上。
5. 最後，我們將裁剪坐標變換為屏幕坐標，我們將使用一個叫做**視口變換**(Viewport Transform)的過程。視口變換將位於-1.0到1.0範圍的坐標變換到由`glViewport`函數所定義的坐標範圍內。最後變換出來的坐標將會送到光柵器，將其轉化為片段。

## 局部空間
局部空間是指物體所在的坐標空間，即對象最開始所在的地方。想像你在一個建模軟件（比如說Blender）中創建了一個立方體。你創建的立方體的原點有可能位於(0, 0, 0)，即便它有可能最後在程序中處於完全不同的位置。甚至有可能你創建的所有模型都以(0, 0, 0)為初始位置（譯注：然而它們會最終出現在世界的不同位置）。所以，你的模型的所有頂點都是在**局部**空間中：它們相對於你的物體來說都是局部的。

## 世界空間

如果我們將所有的物體導入到程序當中，它們有可能會全擠在世界的原點(0, 0, 0)上，這並不是我們想要的結果。我們想為每一個物體定義一個位置，從而能在更大的世界當中放置它們。世界空間中的坐標正如其名：是指頂點相對於（遊戲）世界的坐標。如果你希望將物體分散在世界上擺放（特別是非常真實的那樣），這就是你希望物體變換到的空間。物體的坐標將會從局部變換到世界空間；該變換是由**模型矩陣**(Model Matrix)實現的。

**模型矩陣**是一種變換矩陣，它能通過對物體進行位移、縮放、旋轉來將它置於它本應該在的位置或朝向。你可以將它想像為變換一個房子，你需要先將它縮小（它在局部空間中太大了），並將其位移至郊區的一個小鎮，然後在y軸上往左旋轉一點以搭配附近的房子。你也可以把上一節將箱子到處擺放在場景中用的那個矩陣大致看作一個模型矩陣；我們將箱子的局部坐標變換到場景/世界中的不同位置。

## 觀察空間

**觀察空間**經常被人們稱之OpenGL的**攝像機**(Camera)（所以有時也稱為**攝像機空間**(Camera Space)或**視覺空間**(Eye Space)）。觀察空間是將世界空間坐標轉化為用戶視野前方的坐標而產生的結果。因此觀察空間就是從攝像機的視角所觀察到的空間。而這通常是由一系列的位移和旋轉的組合來完成，平移/旋轉場景從而使得特定的對象被變換到攝像機的前方。這些組合在一起的變換通常存儲在一個**觀察矩陣**(View Matrix)裡，它被用來將世界坐標變換到觀察空間。在下一節中我們將深入討論如何創建一個這樣的觀察矩陣來模擬一個攝像機。
當我們將模型（model）、視圖（view）和投影（projection）矩陣相乘得到的矩陣與一個向量進行乘法時，得到的結果是裁剪空間中相對應的向量。然而，這個矩陣乘積對向量的影響是按逆序執行的，也就是說，$model * view * projection$ 與向量的乘積相當於首先對向量進行投影變換，而不是模型變換，這樣的結果不符合預期。因此，我們需要將其按逆序相乘，即 $projection * view * model$。
## 裁剪空間

在一個頂點著色器運行的最後，OpenGL期望所有的坐標都能落在一個特定的範圍內，且任何在這個範圍之外的點都應該被裁剪掉(Clipped)。被裁剪掉的坐標就會被忽略，所以剩下的坐標就將變為屏幕上可見的片段。這也就是**裁剪空間**(Clip Space)名字的由來。

為了將頂點坐標從觀察變換到裁剪空間，我們需要定義一個**投影矩陣**(Projection Matrix)，它指定了一個範圍的坐標，比如在每個維度上的-1000到1000。投影矩陣接著會將在這個指定的範圍內的坐標變換為標準化設備坐標的範圍(-1.0, 1.0)。所有在範圍外的坐標不會被映射到在-1.0到1.0的範圍之間，所以會被裁剪掉。在上面這個投影矩陣所指定的範圍內，坐標(1250, 500, 750)將是不可見的，這是由於它的x坐標超出了範圍，它被轉化為一個大於1.0的標準化設備坐標，所以被裁剪掉了。

> 如果只是圖元(Primitive)，例如三角形，的一部分超出了裁剪體積(Clipping Volume)，則OpenGL會重新構建這個三角形為一個或多個三角形讓其能夠適合這個裁剪範圍。

> [!TIP]
> 一種常見的做法是每一幀在CPU端計算$view*projection$矩陣，將結果和$model$矩陣一起傳送到GPU，因為場景內的每個物體這兩個矩陣乘的結果都是相同的，所以這樣減小了GPU重複計算$view*projection$的開銷。對於CPU來說，計算矩陣是廉價的，因為CPU只需要每幀計算一次，而GPU需要每個頂點每幀計算一次。而且從CPU發送數據到GPU可能是性能瓶頸，我們需要盡可能少的發送數據。

由投影矩陣創建的**觀察箱**(Viewing Box)被稱為**平截頭體**(Frustum)，每個出現在平截頭體範圍內的坐標都會最終出現在用戶的屏幕上。將特定範圍內的坐標轉化到標準化設備坐標系的過程（而且它很容易被映射到2D觀察空間坐標）被稱之為**投影**(Projection)，因為使用投影矩陣能將3D坐標投影(Project)到很容易映射到2D的標準化設備坐標系中。

一旦所有頂點被變換到裁剪空間，最終的操作——**透視除法**(Perspective Division)將會執行，在這個過程中我們將位置向量的x，y，z分量分別除以向量的齊次w分量；透視除法是將4D裁剪空間坐標變換為3D標準化設備坐標的過程。這一步會在每一個頂點著色器運行的最後被自動執行。

在這一階段之後，最終的坐標將會被映射到屏幕空間中（使用`glViewport`中的設定），並被變換成片段。

將觀察坐標變換為裁剪坐標的投影矩陣可以為兩種不同的形式，每種形式都定義了不同的平截頭體。我們可以選擇創建一個**正射投影矩陣**(Orthographic Projection Matrix)或一個**透視**投影矩陣(Perspective Projection Matrix)。

### 正射投影

![orthographic demo](https://learnopengl-cn.github.io/img/01/08/orthographic_frustum.png)

正射投影矩陣定義的平截頭體類似於一個立方體，需要知道長寬高。只有在這個容器範圍之內才不会被裁剪掉。正射平截頭體直接將平截頭體內部的所有坐標映射為標準化設備坐標，因為每個向量的w分量都沒有進行改變；如果w分量等於1.0，透視除法則不會改變這個坐標。

正射投影矩陣直接將坐標映射到2D平面中，即你的屏幕，但實際上一個直接的投影矩陣會產生不真實的結果，因為這個投影沒有將**透視**(Perspective)考慮進去。所以我們需要**透視投影矩陣**來解決這個問題。

### 透視投影

一個透視平截頭體可以被看作一個不均勻形狀的箱子，在這個箱子內部的每個坐標都會被映射到裁剪空間上的一個點。下面是一張透視平截頭體的圖片：
![perspective demo](https://learnopengl-cn.github.io/img/01/08/perspective_frustum.png)
如果我們需要近大遠小的效果，就需要使用透視投影，這個投影矩陣將給定的平截頭體範圍映射到裁剪空間，除此之外還修改了每個頂點坐標的w值，從而使得離觀察者越遠的頂點坐標w分量越大。被變換到裁剪空間的坐標都會在-w到w的範圍之間（任何大於這個範圍的坐標都會被裁剪掉）。OpenGL要求所有可見的坐標都落在-1.0到1.0範圍內，作為頂點著色器最後的輸出，因此，一旦坐標在裁剪空間內之後，透視除法就會被應用到裁剪空間坐標上：
$$
out = \left( 
\begin{matrix}
x/w\\
y/w\\
z/w
\end{matrix}
\right)
$$
頂點坐標的每個分量都會除以它的w分量，距離觀察者越遠頂點坐標就會越小。這是w分量重要的另一個原因，它能夠幫助我們進行透視投影。最後的結果坐標就是處於標準化設備空間中的。

## LookAt
使用矩陣的好處之一是如果你使用**3個相互垂直（或非線性）的軸定義了一個坐標空間**，你可以用這3個軸外加一個平移向量來創建一個矩陣，並且你可以用**這個矩陣乘以任何向量來將其變換到那個坐標空間**。這正是LookAt矩陣所做的，現在我們有了**3個相互垂直的軸**和一個定義攝像機空間的**位置坐標**，我們可以創建我們自己的LookAt矩陣了：

$$
LookAt=
\begin{bmatrix}
R_x&R_y&R_z&0\\
U_x&U_y&U_z&0\\
D_x&D_y&D_z&0\\
0&0&0&0\\
\end{bmatrix}
*
\begin{bmatrix}
1&0&0&-P_x\\
0&1&0&-P_y\\
0&0&1&-P_z\\
0&0&0&1\\
\end{bmatrix}
$$

其中R是右向量，U是上向量，D是方向向量P是攝像機位置向量。注意，位置向量是相反的，因為我們最終希望把世界平移到與我們自身移動的相反方向。把這個LookAt矩陣作為觀察矩陣可以很高效地把所有世界坐標變換到剛剛定義的觀察空間。LookAt矩陣就像它的名字表達的那樣：它會創建一個看著(Look at)給定目標的觀察矩陣。

一種特殊類型的觀察矩陣，它創建了一個坐標系，其中所有坐標都根據從一個位置正在觀察目標的用戶旋轉或者平移。  
## 歐拉角
被定義為偏航角(Yaw)，俯仰角(Pitch)，和滾轉角(Roll)從而允許我們通過這三個值構造任何3D方向。