---
title: OpenGL中的光照
date: 2025-02-23
tags: ['opengl', 'graphics', 'lighting']
authors: ['Maya']
ai: True
draft: False
---
## 顏色

我們都知道人的眼睛之所以能夠看到東西，有兩種情況：
1. 我們看到了這個物體**發出**的光線
2. 這個物體**反射**了一個發光物體發出的光線

而每個物體都有不同的顏色，這是因為它們對光線有不同的反射能力，比如在陽光下樹葉反射了陽光發出的白色光中的綠色，人眼接收到這個光線從而認為樹葉是綠色的。如果將樹葉放置在紅色燈光下，樹葉會吸收除了綠色光之外的所有光線，從而顯現出黑色。

一個物體對某種顏色的反射能力我們稱為**反射率**

如果我們使用一個三維向量來描述光的顏色，那麼經過反射之後物體的顏色的某一個分量就等於光源的這個分量乘以物體對該顏色分量的反射率。

## 基礎光照

顯示中的光照是極其複雜的，而且會受到諸多因素的影響，這是我們有限的計算能力所無法模擬的。

因此OpenGL的光照使用的是簡化的模型，對現實的情況進行近似，這樣處理起來會更容易一些，而且看起來也差不多一樣。這些光照模型都是基於我們對光的物理特性的理解。其中一個模型被稱為**風氏光照模型**(Phong Lighting Model)。

風氏光照主要有以下三個部分：
- **環境光**(Ambient)
- **漫反射**(Diffuse)
- **鏡面光**(Specular)

## 材質

在現實世界裡，每個物體會對光產生不同的反應。比如，鋼製物體看起來通常會比陶土花瓶更閃閃發光，一個木頭箱子也不會與一個鋼製箱子反射同樣程度的光。有些物體反射光的時候不會有太多的散射(Scatter)，因而產生較小的高光點，而有些物體則會散射很多，產生一個有著更大半徑的高光點。如果我們想要在OpenGL中模擬多種類型的物體，我們必須針對每種表面定義不同的**材質**(Material)屬性。

下面的代碼中我們通過設置漫反射貼圖和鏡面光貼圖來定義一種材質。
```glsl
struct Material {
    sampler2D diffuse;
    sampler2D specular;    
    float shininess;
}; 
```

通過使用漫反射和鏡面光貼圖，我們可以給相對簡單的物體添加大量的細節。我們甚至可以使用**法線/凹凸貼圖**(Normal/Bump Map)或者**反射貼圖**(Reflection Map)給物體添加更多的細節。

## 投光物

### 平行光
當一個光源處於很遠的地方時，來自光源的每條光線就會近似於互相平行。不論物體和/或者觀察者的位置，看起來好像所有的光都來自於同一個方向。當我們使用一個假設光源處於**無限**遠處的模型時，它就被稱為**定向光**，因為它的所有光線都有著相同的方向，它與光源的位置是沒有關係的。

定向光非常好的例子就是太陽。太陽距離我們並不是無限遠，但它已經遠到在光照計算中可以把它視為無限遠了。所以來自太陽的所有光線將被模擬為平行光線。
### 點光源
定向光對於照亮整個場景的全局光源是非常棒的，但除了定向光之外我們也需要一些分散在場景中的**點光源**(Point Light)。點光源是處於世界中某一個位置的光源，它會朝著所有方向發光，但光線會隨著距離逐漸衰減。想像作為投光物的燈泡和火把，它們都是點光源。
#### 光線衰減
隨著光線傳播距離的增長逐漸削減光的強度通常叫做**衰減**(Attenuation)。隨距離減少光強度的一種方式是使用一個線性方程。這樣的方程能夠隨著距離的增長線性地減少光的強度，從而讓遠處的物體更暗。然而，這樣的線性方程通常會看起來比較假。在現實世界中，燈在近處通常會非常亮，但隨著距離的增加光源的亮度一開始會下降非常快，但在遠處時剩餘的光強度就會下降得非常緩慢了。所以，我們需要一個不同的公式來減少光的強度。

$$
F_{att}=\frac{1.0}{K_c+K_l*d+K_q*d^2}
$$
其中常數項$K_c$，一次項$K_l$，二次項$K_q$是我們可以自定義的。
- 常數項通常保持為1.0，它的主要作用是保證分母永遠不會比1小，否則的話在某些距離上它反而會增加強度，這肯定不是我們想要的效果。
- 一次項會與距離值相乘，以線性的方式減少強度。
- 二次項會與距離的平方相乘，讓光源以二次遞減的方式減少強度。二次項在距離比較小的時候影響會比一次項小很多，但當距離值比較大的時候它就會比一次項更大了。
### 聚光

**聚光**(Spotlight)是位於環境中某個位置的光源，它只朝一個特定方向而不是所有方向照射光線。這樣的結果就是只有在聚光方向的特定半徑內的物體才會被照亮，其它的物體都會保持黑暗。聚光很好的例子就是路燈或手電筒。

OpenGL中聚光是用一個世界空間位置、一個方向和一個**切光角**(Cutoff Angle)來表示的，切光角指定了聚光的半徑（譯注：是圓錐的半徑不是距光源距離那個半徑）。對於每個片段，我們會計算片段是否位於聚光的切光方向之間（也就是在錐形內），如果是的話，我們就會相應地照亮片段。

![spotlight demo](https://learnopengl-cn.github.io/img/02/05/light_casters_spotlight_angles.png)
- `LightDir`: 從片段指向光源的向量
- `SpotDir`: 聚光指向的方向
- $\phi$: 指定了聚光半徑的切光角。落在這個角度之外的物體都不會被這個聚光所照亮
- $\theta$: LightDir向量和SpotDir向量之間的夾角。在聚光內部的$\theta$值應該比$\phi$值小
#### 平滑邊緣
我們可以通過定義內外兩個切光角，在這兩個切光角之間進行漸變來實現軟化邊緣的效果，我們可以用這個公式來計算這個值：

$$
I=\frac{\theta-\gamma}{\epsilon}
$$

這裡$\epsilon$(Epsilon)是內（$\phi$）和外圓錐（$\gamma$）之間的餘弦值差（$\epsilon=\phi-\gamma$）。最終的$I$值就是在當前片段聚光的強度。

我們來解釋以下這個函數是怎麼運行的，因為我們內切和外切角需要位於$(0,\frac{\pi}{2})$之間，在這個範圍內餘弦函數是單調遞減的。
因為內切角$\phi$和外切角$\gamma$不變，所以當入射角$\theta$從垂直平面移動到水平與平面也就是從0到$\frac{\pi}{2}$的過程中，$cos(\theta)$是單調遞減的，這個值在$\theta=0$的時候最大，在$\theta>\phi$的時候開始小於1，在$\theta=\gamma$的時候等於0，大於$\gamma$的時候為負數。
如果我們使用截斷函數將函數值限制在$[0,1]$區間內，就可以表示出內切角以內全亮，外切角以外全暗，兩個切角之間光線平滑減弱的效果。