---
title: 深入理解並行控制
date: 2025-05-04
tags: ['operating-system']
authors: ['Maya']
ai: True
draft: false
---
隨著硬體發展的速度遇到瓶頸，單核處理器的速度提升已經越來越慢了，為了取得更好的性能提升，我們可以使用多個CPU來加速計算，但是多個CPU的引入也帶來了更多的問題。

## 共享記憶體
當多個CPU同時操作同一塊共享記憶體的時候，我們平時在寫程式碼的時候的一個很重要的假設就不正確了，那就是只要我不操作這個記憶體，它就不會變。 如果你使用如下的程式碼:

```c
if(cond==true){
	assert(cond)
}
```

在並發的程式中，你的assert可能就會失敗。 這是一個可能的調度順序: 執行緒A剛剛讀取完cond跳轉到了if語句內部，隨後就切換到了另一個執行緒B，這個執行緒在運行過程中修改cond為false，隨後切換到A繼續執行。

這樣的並發衝突是不可容忍的，我可不希望自己的if就像沒if一樣。 

## Data Race
絕大部分的並發問題都是因為Data Race導致的，所謂Data Race其實就是多個執行緒同時並發訪問同一塊記憶體，其中至少有一個操作是寫。

就像上面的例子，導致並發bug的原因就是執行緒A在讀cond，而B並發的寫了cond。
想要避免Data Race，就需要做好執行緒之間的互斥和同步:

## 互斥

### 鎖

為了避免這個問題，我們必須想到一種方法來讓多個執行緒之間實現互斥。 這個方法就是鎖:

```c
lock()
// do something
unlock()
```

在上鎖的這段區域之內，整個世界都安靜了，電腦上只有你一個執行緒在運行，因此沒有必要擔心共享記憶體帶來的一些缺陷。 下面是一個可能的鎖實現:

```c
void lock(){
	while(!ok);
	ok=false;
}
void unlock(){
	ok=true;
}
```

### 原子操作

但是這樣的實現同樣有上面的問題，如果while循環退出之後切換到另一個執行緒了呢?
導致鎖不管用的原因就是這個鎖使用的ok變數，它的load和store並不是原子的，我希望能夠在獲得鎖的一瞬間把ok設置為false，因此硬體就提供了一個原子操作CAS(compare and swap)，通過這個操作我們可以把對ok的修改變成原子的。
```c
// returns the value of address
bool compare_and_swap(bool expected, bool target, bool *addr);
void lock(){
    while(!compare_and_swap(true, false, &ok));
}
void unlock(){
    compare_and_swap(false, true, &ok);
}
```
這裡CAS指令會在比較指向的值與expected是否相等，如果相等就交換target和addr，返回true，否則不做任何操作，並且返回false。
要注意的是這個操作是通過硬體來完成的，不需要軟體或者作業系統來做任何事，他可以保證整個操作的執行不會被打斷，因此這個鎖的實現是正確的。


### mutex
通過上述自旋鎖，我們可以實現基本的互斥效果。然而，由於自旋鎖採用忙等待機制，當持有鎖的執行緒被作業系統調度切換或鎖競爭激烈時，等待執行緒會持續佔用 CPU 資源，降低效率。是否有方法優化鎖的性能，減少 CPU 浪費？

解決方法是利用作業系統的同步原語，例如 C++ 標準庫中的 `std::mutex`。當執行緒無法取得鎖時，`std::mutex` 通過系統調用將執行緒置於等待狀態（而非忙等待），並在鎖被釋放時由作業系統喚醒執行緒繼續執行。

需要注意的是，`std::mutex` 的實現較為複雜，以上僅為簡化描述。實際中，`std::mutex` 可能基於作業系統的 `futex`（Fast Userspace Mutex）等原語，在低競爭場景下先於使用者態短暫自旋嘗試取得鎖，若失敗則通過系統調用使執行緒進入等待狀態。


## 同步
現在我們只解決了關於執行緒之間的互斥問題，同步問題我們還沒有解決。 所謂同步就是需要一個任務的執行需要在另一個任務的結束之後才可以開始。


### 條件變數
我們可以很容易的想到一個同步的實現:
```c
void func1(){
	// perform operations
	task_done = true;
}

void func2(){
	while(!task_done);
}
```

但是同樣的，這個變數並不是原子的，我們可以選擇通過上鎖或者改成原子變數的方法來解決這個問題。 如果我們上了鎖，就需要在條件不成立的情況下釋放鎖並且繼續睡眠，同時，如果條件成立了這個執行緒需要被喚醒。 這就是條件變數的雛形，很幸運的，C++標準庫為我們提供了條件變數:

```cpp
void func1(){
	std::unique_lock lk(mtx);
	// perform operations
	task_done=true;
	cv.notify_all();
	lk.unlock();
}
void func2(){
	std::unique_lock lk(mtx);
	cv.wait(lk,[]{return task_done;})
}
```

每當func2被喚醒的時候，我們會取得lk這把鎖，然後判斷task是否完成，如果沒有完成就陷入阻塞狀態並且釋放鎖lk。 否則就可以帶著鎖繼續執行。
這裡要注意的是，條件變數和鎖都是由執行緒庫或者作業系統來實現的，因此我們不需要擔心上面提到的自旋鎖的問題。 另外，這裡的cv.wait是一個原子操作，它會在等待的同時釋放鎖，不會造成死鎖。
此外，還需要注意的一點是，這個條件變數他是有可能被虛假喚醒的，也就是說，你可能會在沒有notify的情況下被喚醒，因此我們需要在wait之後再次檢查條件是否成立，或者使用C++的帶有謂詞重載的wait，它可以幫助我們循環檢測這個條件，不需要手動寫循環。

### 生產者消費者模型

據說大部分的同步問題都可以通過生產者-消費者模型來解決。 我們可以使用一個佇列來存儲執行緒之間要操作的共享物件，每當生產者將一個物件放入佇列就會去notify一個消費者，同樣的，當消費者消費一個物件之後也會去notify生產者。

### 信號量
信號量是生產者消費者模型可以用到的一個非常好用的抽象，它很適合用來表示這種類似於計數資源的情況。 比方說，我可以假設佇列裡面就緒的資源數是一個信號量，只要消費者嘗試P這個資源，當資源是0的時候就會阻塞等待喚醒，大於0的時候可以取得一個資源，然後處理完之後V一個空閒的資源數信號量。

## 計算圖模型

許多程式中的計算任務可以建模為一個有向無環圖（DAG），其中節點表示獨立的計算任務，邊表示任務之間的依賴關係，確保無循環依賴。
通過對有向無環圖進行拓撲排序並分析其層級結構，若某層級的並行任務數量（即圖的寬度）較大，則表明計算任務具有較高的並發潛力。
此時，可通過多執行緒或分散式計算等並發技術實現加速效果，前提是硬體資源充足且任務粒度適當。