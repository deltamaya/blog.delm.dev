---
title: 进一步理解并发控制
date: 2025-05-04
tags:
  - operating-system
authors:
  - Maya
ai: false
draft: true
---
随着硬件发展的速度遇到瓶颈, 单核处理器的速度提升已经越来越慢了, 为了取得更好的性能提升, 我们可以使用多个CPU来加速计算, 但是多个CPU的引入也带来了更多的问题.

## 共享内存
当多个CPU同时操作同一块共享内存的时候, 我们平时在写代码的时候的一个很重要的假设就不正确了, 那就是只要我不操作这个内存, 它就不会变. 如果你使用如下的代码:

```c
if(cond==true){
	assert(cond)
}
```

在并发的程序中, 你的assert可能就会失败. 一个可能的调度顺序就是, 线程A刚刚读取完cond跳转到了if语句内部, 随后就切换到了另一个线程B, 这个线程在运行过程中修改cond为false, 随后切换到A继续执行.

这样的并发冲突是不可容忍的, 我可不希望自己的if就像没if一样. 

## 互斥

### 锁

为了避免这个问题, 我们必须想到一种方法来让多个线程之间实现互斥. 这个方法就是锁:

```c
lock()
// do something
unlock()
```

在上锁的这段区域之内, 整个世界都安静了, 计算机上只有你一个线程在运行, 因此没有必要担心共享内存带来的一些缺陷. 下面是一个可能的锁实现:

```c
void lock(){
	while(!ok);
	ok=false;
}
void unlock(){
	ok=true;
}
```

### 原子操作

但是这样的实现同样有上面的问题, 如果while循环退出之后切换到另一个线程了呢?
导致锁不管用的原因就是这个锁使用的ok变量, 它的load和store并不是原子的, 我希望能够在获得锁的一瞬间把ok设置为false, 因此硬件就提供了一个原子操作CAS(compare and swap), 通过这个操作我们可以把对ok的修改变成原子的.
```c
// returns the value of address
bool compare_and_swap(bool expected, bool target, bool *addr);
void lock(){
 while(!compare_and_swap(true, false, &ok));
}
void unlock(){
	compare_and_swap(false, true, &ok);
}
```
这里CAS指令会在比较指向的值与expected是否相等, 如果相等就相等target和addr, 返回true, 否则不做任何操作, 并且返回false.
要注意的是这个操作是通过硬件来完成的, 不需要软件或者操作系统来做任何事, 他可以保证整个操作的执行不会被打断, 因此这个锁的实现是正确的.


### mutex
通过上述自旋锁，我们可以实现基本的互斥效果。然而，由于自旋锁采用忙等待机制，当持有锁的线程被操作系统调度切换或锁竞争激烈时，等待线程会持续占用 CPU 资源，降低效率。是否有方法优化锁的性能，减少 CPU 浪费？

解决方法是利用操作系统的同步原语，例如 C++ 标准库中的 std::mutex。当线程无法获取锁时，std::mutex 通过系统调用将线程置于等待状态（而非忙等待），并在锁被释放时由操作系统唤醒线程继续执行。

需要注意的是，std::mutex 的实现较为复杂，以上仅为简化描述。实际中，std::mutex 可能基于操作系统的 futex（Fast Userspace Mutex）等原语，在低竞争场景下先于用户态短暂自旋尝试获取锁，若失败则通过系统调用使线程进入等待状态。


## 同步
现在我们只解决了关于线程之间的互斥问题, 同步问题我们还没有解决. 所谓同步就是需要一个任务的执行需要在另一个任务的结束之后才可以开始.


### 条件变量
我们可以很容易的想到一个同步的实现:
```c
void func1(){
	// perform operations
	task_done = true;
}

void func2(){
	while(!task_done);
}
```

但是同样的, 这个变量并不是原子的, 我们可以选择通过上锁或者改成原子变量的方法来解决这个问题. 如果我们上了锁, 就需要在条件不成立的情况下释放锁并且继续睡眠, 同时, 如果条件成立了这个线程需要被唤醒. 这就是条件变量的雏形, 很幸运的, C++标准库为我们提供了条件变量:

```cpp
void func1(){
	std::unique_lock lk(mtx);
	// perform operations
	task_done=true;
	cv.notify_all();
	lk.unlock();
}
void func2(){
	std::unique_lock lk(mtx);
	cv.wait(lk,[]{return task_done;})
}
```

每当func2被唤醒的时候, 我们会获得lk这把锁, 然后判断task是否完成, 如果没有完成就陷入等待状态并且释放锁lk. 否则就可以带着锁继续执行.

### 生产者消费者模型

99%的同步问题都可以通过生产者-消费者模型来解决. 我们可以使用一个队列来存储线程之间要操作的共享对象, 每当生产者将一个对象放入队列就会去notify一个消费者, 同样的, 当消费者消费一个对象之后也会去notify生产者.

### 信号量
信号量是生产者消费者模型可以用的的一个非常好的抽象, 它很适合用来表示这种类似于计数资源的情况. 比方说, 我可以假设队列里面就绪的资源数是一个信号量, 只要消费者尝试P这个资源, 当资源是0的时候就会阻塞等待唤醒, 大于0的时候可以获取一个资源, 然后处理完之后V一个空闲的资源数信号量.

## 计算图模型

许多程序中的计算任务可以建模为一个有向无环图（DAG），其中节点表示独立的计算任务，边表示任务之间的依赖关系，确保无循环依赖。
通过对有向无环图进行拓扑排序并分析其层级结构，若某层级的并行任务数量（即图的宽度）较大，则表明计算任务具有较高的并发潜力。
此时，可通过多线程或分布式计算等并发技术实现加速效果，前提是硬件资源充足且任务粒度适当。

