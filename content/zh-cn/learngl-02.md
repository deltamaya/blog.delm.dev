---
title: 进阶OpenGL
date: 2025-03-11
tags:
  - graphics
  - opengl
authors:
  - Maya
ai: false
draft: true
---
# 深度测试
现在我们知道OpenGL中的每一个片段都有一个自己的坐标, 其中的z坐标表示距离屏幕的距离, 比如当我们需要近处的物体遮挡远处的物体时, 就需要进行深度测试. 深度测试是指根据片段的深度(z坐标)来判断该片段是否应该被展示. 深度测试在没有优化的情况下是在片段着色器之后, 在屏幕空间运行的.

> [!NOTE]
> 现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。
> 片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。



深度测试默认是关闭的, 可以通过`GL_DEPTH_TEST`选项来启用它.
```cpp
glEnable(GL_DEPTH_TEST);
```

如果一个片段通过了深度测试, 接下来会将这个片段的z值更新深度缓冲区, 用来进行后面的判断. 如果没有通过测试, 就会直接丢弃该片段. 如果开启了深度缓冲, 你还需要在每一次渲染循环中清空深度缓冲, 否则上一帧的深度缓冲就会对当前帧的深度探测产生负面影响:
```cpp
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```
如果你希望再有的时候只进行探测而不进行更新深度缓冲区的操作, 可以通过设置深度掩码`DepthMask`为`false`即可
```cpp
glDepthMask(false);
```
## 深度测试函数
我们可以通过不同的深度测试函数来进行深度探测, 默认的比较方法是`GL_LESS`, 他会丢弃当深度值大于等于当前深度缓冲值的所有片段.
```cpp
glEnable(GL_DEPTH_TEST);
glDepthFunc(GL_LESS);
```
OpenGL还提供了`GL_ALWAYS`, `GL_NEVER`, `GL_EQUAL`, `GL_GEQUAL`等内置的探测函数,
加入我们启用了`GL_ALWAYS`深度测试将永远通过, 我们能看到的永远是我们最后进行渲染的片段.

## 精度
深度缓冲中包含了一个[0.0, 1.0]的深度值, 它可以代表平截头体从近平面到远平面的所有z坐标. 这个变换通常是一个这样的变换函数: 

$$
F_{depth}=\frac{1/z-1/near}{1/far-1/near}
$$
使用这样的非线性变换函数而不是一个线性变换可以使我们在近处的探测精度更高, 而远处的精度更低, 增强了近处的视觉体验.

## 深度冲突
一个常见的视觉错误就是当两个片段的深度值非常相近以至于深度测试无法明确判断谁在前谁在后的时候就会产生深度冲突. 看起来就是两个片段在竞争谁处于顶端, 具体表现就是一个区域可以看到两个片段高频交替显示或者是两个片段的条纹. 深度冲突在远处格外明显, 因为非线性变换导致远处的精度较低.

我们可以通过如下方法来规避深度冲突:

- 不要将两个物体摆放的太近, 很有效.
- 尽可能将近平面设置的更远, 如果近平面更远就意味着我们可以在更远的距离拥有更高的精度, 但是设置过大可能导致物体直接被裁剪掉.
- 使用更高精度的缓冲, 大部分缓冲都是24bit的, 但是大部分显卡都支持32bit的缓冲, 这可以极大的提升精度.
# 模板测试


# 混合

# 面剔除

# 帧缓冲

# 立方体贴图

# 几何着色器

