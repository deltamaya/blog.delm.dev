---
title: " 进一步理解虚拟内存"
date: 2025-04-29
tags:
  - operating-system
authors:
  - Maya
ai: false
draft: false
---
最近在学习的过程中发现自己对操作系统和内存理解的知识储备有些不太够用了, 于是再来学习一下关于操作系统的一些知识, 就从虚拟内存开始吧:

## 什么是虚拟内存?
操作系统的一大功能就是对硬件进行**抽象**, 来向软件提供一个接口来操作硬件, 而虚拟内存就是操作系统对内存的抽象, 虚拟内存是由**操作系统**管理的.

如果是应用直接操作物理内存, 就像单片机, 那么一个硬件上几乎就不能运行多个程序, A程序的程序员并不知道B程序要使用哪些内存, 因此A程序和B程序就会相互影响彼此的内存, 这是不可接受的. 因此操作系统抽象出了虚拟内存, 对应用程序来说就像自己独占所有内存一样.

虚拟内存的是抽象出来的的, 所以它的大小并不受限于物理内存的大小. 比如说, 32位的系统上可以有$2^{32}$也就是4G的虚拟内存, 但是内存却可以是1G甚至只有几百K.

## 虚拟内存的作用

就像刚才说的, 虚拟内存可以改变进程对内存的感知, 允许多个进程操作同时操作内存而不会彼此影响. 操作系统还可以对进程实际使用的内存进行重新排布, 压缩甚至是换出到磁盘, 这些操作应用程序**都不会感知到**. 

## 虚拟内存的是如何实现的

操作系统通过分页来对内存这个巨大的字节数组进行划分, 一个页的大小一般是4K, 每一个内存字节的地址都可以由一个页号+一个页面内的偏移量来计算得到. 同样的, 物理内存也可以划分为一个个页面, 它们之间的大小是相同的.

那么, 每个虚拟内存页就可以有3种状态:
1. 已经被映射, 并且存放在物理内存
2. 已经被映射, 没有存放在物理内存
3. 没有被映射

这里的“映射”指的是将虚拟内存映射到进程的地址空间, 一个应用程序想要操作虚拟内存必须将它映射到自己的**地址空间**, 否则就会触发**段错误**. 所谓段错误就是应用程序访问到了不属于自己的虚拟内存段或者没有以指定的特权级别访问了某个虚拟内存段.

对应用程序来说, 对内存的使用流程大致如下: 

1. 向操作系统请求对指定大小的或者位置的虚拟内存进行映射, 如果成功, 那么这些虚拟内存的状态就是上面的状态2
2. 使用内存, 操作系统如果发现进程使用到了状态2的内存, 但是发现这个虚拟内存页没有缓存在物理内存中, 就会触发缺页中断, 由操作系统对应的终端处理程序来将这个虚拟内存页放到物理内存, 转化为状态1, 这个过程中可能还会涉及到虚拟内存页的换出.
3. 释放内存, 进程向操作系统请求解除虚拟内存映射, 将进程的这些虚拟内存设置为状态3, 那么物理内存中的实际数据也可以被释放了

但是现在依旧没有解释为什么虚拟内存可以让多个进程同时运行, 如果A和B同时操作内存0x114514为什么不会发生错误呢?

这是因为操作系统为每一个进程维护一个页表, 我们先假设AB进程都正确请求了内存, 并且0x114514内存对应的虚拟内存页都是状态1, 其中的一个表项记录了进程的每一个虚拟内存页映射到物理页框的哪个位置, 比如A的0x114514对应的页可能在物理内存0x1919处, B的0x114514可能对应0x810的物理内存位置.
当然, 上面仅仅是举例说明不同进程的同一个虚拟地址会映射到不同的物理地址, 实际的具体数值可能没有很精确的对应现实情况.


## 虚拟内存的优化

简单介绍:
### 多级页表
如果一个32位系统, 地址空间有$2^{32}$也就是4G, 如果我们采用4K的页就需要每个进程维护$2^{32}/2^{12}=1M$个页的页表, 如果一个页表项占用4B, 就需要4M每个进程, 如果是64位的地址空间就更加恐怖了.

因此, 我们引入了多级页表, 通过层级结构的页表来减少需要记录的页表项数量.

## TLB
如果每次访存的操作都需要去查页表未免太慢了, 因此我们又引入了**快表**(TLB), 直接缓存最常用的虚拟页映射, 命中缓存的情况下大幅度减少访存的时间开销.